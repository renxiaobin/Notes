1.接口的default关键字
Java8允许给接口添加一个非抽象的方法（有具体实现），只需要使用 default关键字即可，这个特征又叫做扩展方法，该方法当然也可以重写覆盖其实现
interface Formula {
    double calculate(int a);
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}

Formula formula = new Formula() {
    @Override
    public double calculate(int a) {
        return sqrt(a * 100);
    }
};
formula.calculate(100);     // 100.0
formula.sqrt(16);           // 4.0


2.Lambda表达式
使用表达式可以使得代码更加简洁
原先使用比较器匿名对象来排列字符串的方法
Collections.sort(names, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});
可以改成
Collections.sort(names, (String a, String b) -> {
    return b.compareTo(a);
});
函数体只有一行代码的，可以去掉大括号{}以及return关键字，变为
Collections.sort(names, (String a, String b) -> b.compareTo(a));
Java编译器可以自动推导出参数类型，所以可以不用再写一次类型，变为
Collections.sort(names, (a, b) -> b.compareTo(a));

3.函数式接口
仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法（因为上述的 default 方法不算抽象方法，所以也可以给函数式接口添加默认方法）给Interface添加 @FunctionalInterface 注解，然后通过lambda表达式当作任意只包含一个抽象方法的接口类型，此时有有注解的接口如果有多个抽象方法会报错（其实没有注解也可以正确运行，因为Java8之前就有将lambda表达式映射到一个单方法的接口上的实现了）
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
Converter<String, Integer> converter = (from) -> Integer.valueOf(from);
Integer converted = converter.convert("123");
System.out.println(converted);    // 123

4.方法与构造函数引用
Java8允许使用 :: 关键字来传递方法或者构造函数的引用，如上面的代码可以改成
Converter<String, Integer> converter = Integer::valueOf;
Integer converted = converter.convert("123");
System.out.println(converted);   // 123
上面的代码展示了如何引用一个静态方法，当然也可以引用一个对象的方法
String something = new String("01234");
Converter<String, Integer> converter = something::indexOf;
Integer converted = converter.convert("123");
System.out.println(converted);   // 1
构造函数也可以使用::关键字来引用
class Person {
    String firstName;
    String lastName;
    Person() {}
    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
interface PersonFactory<P extends Person> {
    P create(String firstName, String lastName);
}
PersonFactory<Person> personFactory = Person::new;
Person person = personFactory.create("Peter", "Parker");
只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数


