1.Java中的线程安全的集合：
Vector：就比Arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用；
Statck：堆栈类，先进后出；
Hashtable：就比Hashmap多了个线程安全，不推荐使用；
Enumeration：枚举，相当于迭代器；

2.StringBuffer是线程安全的，而StringBuilder不是。
线程安全是指任何时刻都只有一个线程访问临界资源。线程安全 并不是说他的一系列操作是同步的，只是对于他执行某个方法的时候不允许别的线程去改变。针对一个类来说是不是线程安全就要看，多个线程在同时在运行，这些线程可能会同时执行某个方法；但是每次运行结果和单线程执行的结果一样，那么就可以说是线程安全的。

3.AtomicInteger，一个提供原子操作的Integer的类。
在Java语言中，对于int类型来说，++i和i++操作并不是线程安全的，高并发访问时计算会有误。而AtomicInteger中，使用了private volatile int value;  Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。而Java语言规范指出：为了获取最佳的运行速度，允许线程保留共享变量的副本，当这个线程进入或者离开同步代码块时，才与共享成员变量进行比对，如果有变化再更新共享成员变量。这样当多个线程同时访问一个共享变量时，可能会存在值不同步的现象。因此，使用volatile这个值的作用就是告诉VM：对于这个成员变量不能保存它的副本，要直接与共享成员变量交互。这个就是保证AtomicInteger线程安全的根源。所以以后当多个线程同时访问一个共享变量时，可以使用volatile，但是当访问的变量已在synchronized代码块中时，不必使用，此外使用volatile将使得VM优化失去作用，导致效率较低。

4.如果有多个线程需要访问HashMap,可以使用Collections.synchronizedMap(Map m)方法；该方法返回由指定映射支持的同步（线程安全的）映射，实际上该方法只是一个工具方法, 将传入Map的实现方法加一个同步(synchronized)锁代理,内部还是调用实现的对应方法.
