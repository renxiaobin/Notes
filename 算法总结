1.冒泡排序
比较每一对相邻的元素，若前者大于后者，则交换位置；第一遍后最后一个元素显然为最大的元素；继续循环比较每一对相邻元素（除了上一次循环得出的最后元素）。

for(int i=arr.length-1;i>0;i--){
  for(int j=0;j<i;j++){
    if(arr[j]>arr[j+1]){
      int temp = arr[j];
      arr[j] = arr[j+1];
      arr[j+1] = temp;
    }
  }
}

2.选择排序
循环对比数组中的元素，找出最小元素，记录其下标，然后和数组第一个元素交换位置；此时第一个元素变成最小，然后剩下的元素重复此步骤，找出第二小的元素并交换其位置到第二位，直到倒数第二个元素位置也确定，最后的即为最大。

for(int i=0;i<arr.length-1;i++){
  int minIndex = i;
  for(int j=i+1;j<arr.length;j++){
    if(arr[j]<arr[minIndex]){
      minIndex = j;
    }
  }
  if(minIndex != i){
    int temp = arr[i];
    arr[i] = arr[minIndex];
    arr[minIndex] = temp;
  }
}

3.插入排序
设第一个元素a为已排序的最后一个元素，下一个元素b与其比较，若元素a大，则元素a位置向后挪一位，并元素b将继续朝前比较；直到找到小于或等于元素b的位置，此时将b放置在该位置的下一个位置；重复上述步骤直到最后一个元素。

for(int i<1;i<arr.length;i++){
  int temp = arr[i];
  int j = i-1;
  while(j>=0 && arr[j]>temp){
    arr[j+1] = arr[j];
    j--;
  }
  arr[j+1] = temp;
}

4.希尔排序
先取正整数d1<元素个数n，把所有元素序号相隔d1的分成一组，组内进行直接插入排序；然后取d2<d1重复分组和排序的操作；当di=1时，所有元素此时都在一个组中排序完成。


5.归并排序
将相邻的两个元素比较进行归并操作，形成floor（n/2）个分组，每组有2个元素；再次对上述分组两两进行归并操作，形成floor（n/4）个分组；循环上述步骤，直到所有元素排序完成，此时只剩一个分组。


6.快速排序
任取一个元素，将所有小于它的元素放在它前面形成一个序列，大于它的放在后面形成另一个序列，再对这两个序列重复上述过程。

7.堆排序
建立最大堆，其中的任意节点的值必定大于左右子节点的值，堆顶的节点值最大，主要消耗在建立堆和调整堆上。


