1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机（Java Virtual Machine）是一个可以执行Java字节码的虚拟机进程，Java源文件被编译成能被Java虚拟机执行的字节码文件（也就是.class），Java虚拟机屏蔽了具体操作系统的相关信息，使得只需要字节码就可以运行Java程序。

2.JDK和JRE的区别是什么？
JDK（Java Development Kit）是完整的Java语言开发工具包，主要包括JRE、编译器以及JavaDoc等工具，它使得开发者能够开发、编译、执行Java程序；而JRE（Java Runtime Environment）是Java程序运行所需要的环境集合，包括了Java虚拟机以及Java核心的类库。总的来说，前者包含了后者。

3.”static”关键字是什么意思？Java中是否可以覆盖(override)一个static的方法？
static关键字表明一个成员变量或者成员方法可以在没有类实例的情况下被访问；Java中不能覆盖一个static方法，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的，static方法和类的任何实例都是不相关的，所以不适用。

4.是否可以在static环境中访问非static变量？
static变量在Java中属于该类，它在所有类实例中的值都是一样的，当类被Java虚拟机载入时，static变量就被初始化了，如果此时尝试访问非static变量，编译器会报错，因为此时非static变量并没有被创建出来（没有实例）。

5.Java支持的基本数据类型有哪些？什么是自动拆装箱？
Java支持八种基本数据类型：byte、short、int、long、float、double、boolean、char；
自动装箱是指Java编译器从基本数据类型到相应的对象包装类型之间做的一个转化，比如，int转成Integer，double转成Double等等，反之，就是自动拆箱。

6.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？
方法覆盖是指子类重新定义了父类中的方法，其必须有相同的方法名，参数列表和返回类型；方法重载则发生在同一个类里面的多个方法中，此时方法名相同但参数不同。

7.Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？
当一个新的对象被创建时，会调用类中定义的构造函数。每一个类都至少有一个构造函数，没有定义的情况下编译器也会提供一个默认的构造函数；
类中可以定义多个构造函数，由于函数名必然相同，则各函数的参数列表必须唯一，调用时，通过不同的参数列表来确认调用的函数；
复制构造函数是一种特殊的构造函数，主要用于基于同一类的对象来完成其他对象的构建和初始化，Java不会创建默认的复制构造函数；

8.Java支持多继承么？
Java不支持多继承，每个类只能继承一个类，但可以实现多个接口。

9.接口（Interface）和抽象类（Abstract Class）的区别是什么？
*接口中所有的方法都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法；
*类可以实现很多接口，但是只能继承一个抽象类；
*类如果要实现一个接口，必须要实现接口中的所有方法，但是继承抽象类可以不需要实现类中声明的所有方法（此时子类也须是抽象的）；
*接口中声明的变量默认都是final的，抽象类可以包含非final的变量；
*接口中的成员函数默认是public的，抽象类成员函数可以是private、protected或者public；
*接口是绝对抽象的，不可以被实例化，抽象类也不能被实例化，但是其中包含的main方法可以被调用；

10.什么是值传递和引用传递？
值传递，意味着传递了对象的一个副本，即使改变副本的值，也不会影响到原来的对象的值；
引用传递，则意味传递的不是实际的对象，而是对象的一个引用，对引用对象做的改变会反映到实际对象中。

11.进程和线程的区别是什么？
进程是正在执行的应用程序，而线程是进程内部的一个执行序列；一个进程可以有多个线程；进程拥有自己独立的内存区域；

12.创建线程有几种不同的方式？你喜欢哪一种？为什么？
有三种方式能创建线程：
*继承Thread类
*实现Runnable接口
*使用Executor框架来创建线程池
更喜欢实现Runnable接口这种方式，因为Java不支持多继承，若已经设计继承其他类的情况下，就不能再继承Thread类，只能实现接口

13.概括的解释下线程的几种可用状态。
*创建（New）
*可运行态（Runnable）
*运行中（Running）
*阻塞/非运行态（Blocked）
*死亡（Dead）

14.同步（synchronized）方法和同步代码块的区别是什么？
Java中，每一个对象有一把锁，线程可以使用synchronized关键字来获取对象上的锁，锁定后同一时间只能有一个线程执行被锁定的代码；synchronized关键字可以用在方法级别（粗粒度锁）或者代码块级别（细粒度锁）。

15.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？
监视器和锁在Java虚拟机中是一块使用的，监视器监视一块同步代码块，确保一次只有一个线程在执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

16.什么是死锁(deadlock)？
两个或多个进程都在互相等待对方执行完毕才能继续往下执行的时候就发生了死锁，结果就是多个进程都陷入了无限的等待中。

17.如何确保N个线程可以访问N个资源同时又不导致死锁？
制定获取锁的顺序，并强制线程按照指定的顺序获取锁。

18.Java集合类框架的基本接口有哪些？
*Collection：代表一组对象，每一个对象都是它的子元素；
*Set：不包含重复元素的Collection；
*List：有顺序的Collection，可以包含重复元素；
*Map：键值对，键不能重复；

19.为什么集合类没有实现Cloneable和Serializable接口？
为了让每一种具体的实现类能够选择自己的方式对元素进行保存和排序，如有的允许重复有的则不行。而克隆(cloning)或者是序列化(serialization)的语义和含义都是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。

20.什么是迭代器(Iterator)？
Iterator接口提供了很多对集合元素进行迭代的方法，且不必暴露集合对象的内部细节，每一个集合类都包含了可以返回迭代器实例的迭代方法，迭代器可以按照一定顺序访问容器中的各个元素。

21.Iterator和ListIterator的区别是什么？
*Iterator可以遍历Set和List集合，但是ListIterator只能用于遍历List；
*Iterator对集合只能是前向遍历，ListIterator可以前向也可以后向；
*ListIterator实现了Iterator接口，并扩展了其他功能，如：增加元素，替换元素，获取前一个元素和后一个元素的索引等等。

22.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？
Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。

23.Java中的HashMap的工作原理是什么？
HashMap是以键值对（key-value）的形式存储元素的。HashMap需要一个hash函数，它使用hashCode（）和equals（）方法来添加和检索元素。当调用push（）方法时，会计算key的hash值，如果key存在，则更新value的值，否则把键值对存储在集合中合适的索引上。

24.HashMap中hashCode()和equals()方法的重要性体现在什么地方？
HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素，所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。

25.HashMap和Hashtable有什么区别？
HashMap和Hashtable都实现了Map接口，有许多相似的特性，但是也有如下不同点：
*HashMap允许键和值是null，而Hashtable不允许；
*HashMap不是同步的，而Hashtable是同步的，所以前者适合单线程后者适合多线程环境；
*HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)；
*Hashtable是遗留类，不推荐使用。

26.数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？
*Array可以包含基本类型和对象类型，ArrayList只能包含对象类型；
*Array大小是固定的，ArrayList的大小是动态变化的；
*ArrayList提供了更多的方法，如：addAll（）、removeAll（）等等；
对于基本类型数据，集合使用自动装箱来减少编码工作量，但是，当处理固定大小的基本数据类型时，效率较低；

27.ArrayList和LinkedList有什么区别？
ArrayList和LinkedList都实现了List接口，他们有以下的不同点：
*ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)；
*相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引；
*LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。

28.Comparable和Comparator接口是干什么的？列出它们的区别。
Java提供了只包含一个compareTo()方法的Comparable接口，这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象；
Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。

29.什么是Java优先级队列(Priority Queue)？
PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。

30.你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？
大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。

31.如何权衡是使用无序的数组还是有序的数组？
有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)；所以，可以根据插入操作和查找操作所占的比例来判断。

32.Java集合类框架的最佳实践有哪些？
*根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList；
*有些集合类允许指定初始容量，因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容；
*为了类型安全，可读性和健壮性的原因总是要使用泛型，同时，使用泛型还可以避免运行时的ClassCastException；
*使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法；
*编程的时候接口优于实现；
*底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。

33.Enumeration接口和Iterator接口的区别有哪些？
Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。

34.HashSet和TreeSet有什么区别？
HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)；另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。

35.Java中垃圾回收有什么目的？什么时候进行垃圾回收？
垃圾回收的目的是识别并且丢弃程序不再使用的对象来释放和重用资源。

36.System.gc()和Runtime.gc()会做什么事情？
这两个方法用来提示JVM要进行垃圾回收，但是，立即开始还是延迟进行垃圾回收是取决于JVM的。

37.finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？
在释放对象占用的内存之前，垃圾收集器会调用对象的finalize()方法。一般建议在该方法中释放对象持有的资源。

38.如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
不会，在下一个垃圾回收周期中，这个对象将是可被回收的。

39.Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?
JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收；堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。
永久代或者“Perm Gen”包含了JVM需要的应用元数据，这些元数据描述了在应用里使用的类和方法。注意，永久代不是Java堆内存的一部分；永久代存放JVM运行时使用的类。永久代同样包含了Java SE库的类和方法。永久代的对象在full GC时进行垃圾收集。

40.串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？
吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。

41.在Java中，对象什么时候可以被垃圾回收？
当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。

42.JVM的永久代中会发生垃圾回收么？
垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。永久代已经在Java8中取消，新加了一个叫做元数据区的native内存区。

43.Java中的两种异常类型是什么？他们有什么区别？
Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。

44.Java中Exception和Error有什么区别？
Exception和Error都是Throwable的子类，Exception用于用户程序可以捕获的异常情况，Error定义了不期望被用户程序捕获的异常。

45.throw和throws有什么区别？
throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。

46.异常处理的时候，finally代码块的重要性是什么？
无论是否抛出异常，finally代码块总是会被执行，就算是没有catch语句同时又抛出异常的情况下，finally代码块仍然会被执行；此外，finally代码块主要用来释放资源，比如：I/O缓冲区，数据库连接。

47.异常处理完成以后，Exception对象会发生什么变化？
Exception对象会在下一个垃圾回收过程中被回收掉。

48.finally代码块和finalize()方法有什么区别？
无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源；finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。

49.什么是Applet？
java applet是能够被包含在HTML页面中并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。

50.解释一下Applet的生命周期
Applet可以经历下面的状态：
*Init：每次被载入的时候都会被初始化。
*Start：开始执行applet。
*Stop：结束执行applet。
*Destroy：卸载applet之前，做最后的清理工作。

51.当applet被载入的时候会发生什么？
首先，创建applet控制类的实例，然后初始化applet，最后开始运行。

52.Applet和普通的Java应用程序有什么区别？
Applet是运行在启用了java的浏览器中，Java应用程序是可以在浏览器之外运行的独立的Java程序。但是，它们都需要有Java虚拟机；进一步来说，Java应用程序需要一个有特定方法签名的main函数来开始执行。Java applet不需要这样的函数来开始执行；最后，Java applet一般会使用很严格的安全策略，Java应用一般使用比较宽松的安全策略。

53.Java applet有哪些限制条件？
主要是由于安全的原因，给applet施加了以下的限制：
*applet不能够载入类库或者定义本地方法。
*applet不能在宿主机上读写文件。
*applet不能读取特定的系统属性。
*applet不能发起网络连接，除非是跟宿主机。
*applet不能够开启宿主机上其他任何的程序。

54.什么是不受信任的applet？
不受信任的applet是不能访问或是执行本地系统文件的Java applet，默认情况下，所有下载的applet都是不受信任的。

55.从网络上加载的applet和从本地文件系统加载的applet有什么区别？
当applet是从网络上加载的时候，applet是由applet类加载器载入的，它受applet安全管理器的限制；当applet是从客户端的本地磁盘载入的时候，applet是由文件系统加载器载入的；从文件系统载入的applet允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验。

56.applet类加载器是什么？它会做哪些工作？
当applet是从网络上加载的时候，它是由applet类加载器载入的。类加载器有自己的java名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间；
当浏览器通过网络载入applet的时候，applet的类被放置于和applet的源相关联的私有的名称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守Java语言规范，确保不会出现堆栈溢出(stack overflow)或者下溢(underflow)，传递给字节码指令的参数是正确的。

57.applet安全管理器是什么？它会做哪些工作？
applet安全管理器是给applet施加限制条件的一种机制，浏览器可以只有一个安全管理器，安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。

58.弹出式选择菜单(Choice)和列表(List)有什么区别？
Choice是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。Choice中一次只能选中一个选项。List同时可以有多个元素可见，支持选中一个或者多个元素。

59.什么是布局管理器？
布局管理器用来在容器中组织组件。

60.滚动条(Scrollbar)和滚动面板(JScrollPane)有什么区别？
Scrollbar是一个组件，不是容器；而ScrollPane是容器，ScrollPane自己处理滚动事件。

61.哪些Swing的方法是线程安全的？
只有3个线程安全的方法： repaint(), revalidate(), and invalidate()。

62.说出三种支持重绘(painting)的组件。
Canvas, Frame, Panel,和Applet支持重绘。

63.什么是裁剪(clipping)？
限制在一个给定的区域或者形状的绘图操作就做裁剪。

64.MenuItem和CheckboxMenuItem的区别是什么？
CheckboxMenuItem类继承自MenuItem类，支持菜单选项可以选中或者不选中。

65.边缘布局(BorderLayout)里面的元素是如何布局的？
BorderLayout里面的元素是按照容器的东西南北中进行布局的。

66.网格包布局(GridBagLayout)里面的元素是如何布局的？
GridBagLayout里面的元素是按照网格进行布局的。不同大小的元素可能会占据网格的多于1行或一列。因此，行数和列数可以有不同的大小。

67.Window和Frame有什么区别？
Frame类继承了Window类，它定义了一个可以有菜单栏的主应用窗口。

68.裁剪(clipping)和重绘(repainting)有什么联系？
当窗口被AWT重绘线程进行重绘的时候，它会把裁剪区域设置成需要重绘的窗口的区域。

69.事件监听器接口(event-listener interface)和事件适配器(event-adapter)有什么关系？
事件监听器接口定义了对特定的事件，事件处理器必须要实现的方法。事件适配器给事件监听器接口提供了默认的实现。

70.GUI组件如何来处理它自己的事件？
GUI组件可以处理它自己的事件，只要它实现相对应的事件监听器接口，并且把自己作为事件监听器。

71.Java的布局管理器比传统的窗口系统有哪些优势？
Java使用布局管理器以一种一致的方式在所有的窗口平台上摆放组件。因为布局管理器不会和组件的绝对大小和位置相绑定，所以他们能够适应跨窗口系统的特定平台的不同。

72.Java的Swing组件使用了哪种设计模式？
Java中的Swing组件使用了MVC(视图-模型-控制器)设计模式。

73.什么是JDBC？
JDBC是允许用户在不同数据库之间做选择的一个抽象层，JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。

74.解释下驱动(Driver)在JDBC中的角色。
JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。

75.Class.forName()方法有什么作用？
这个方法用来载入跟数据库建立连接的驱动。

76.PreparedStatement比Statement有什么优势？
PreparedStatements是预编译的，因此，性能会更好；同时，不同的查询参数值，PreparedStatement可以重用。
