1.通过Java访问URL地址获取资源
URL url = new URL("http://www.***.com/");
InputStream is = url.openConnection().getInputStream();
上述通过URL访问一个地址时，如果遇到“java.io.IOException: Server returned HTTP response code: 403 for URL. But it's ok when open the url using browser.”这样的错误，可能是指服务器检查了User-Agent（用户代理，一般是浏览器）的HTTP Header异常，此时需要设置一下：
URLConnection conn = url.openConnection();
conn.setRequestProperty("User-Agent", "Mozilla/5.0");

2.加载类的方法
通过new一个新的类对象，这是静态加载类的方式，如果找不到该类，会导致编译不通过；
通过Class.forName("className")方法加载类的方式，是动态加载类的方式，运行时才会去查找该类是否存在。然后可以通过newInstance()方法创建类的实例对象，而为了确认创建的类是哪个具体的类，可以将这些类实现一个公共的接口，将实例对象强制转化为该接口类型。

3.Java对象的内存分配
(1) 寄存器（register）。这是最快的保存区域，这是主要由于它位于处理器内部。然而，寄存器的数量十分有限，所以寄存器是需要由编译器分配的。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。
(2) 堆栈(stack)。位于通用RAM（随机访问存储器）中。可通过它的“堆栈指针” 获得处理的直接支持。堆栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间” 。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性，所以尽管有些Java 数据要保存在堆栈里— — 特别是对象句柄（也称对象的引用），但Java对象并不放到其中。
(3) 堆(heap)。一种通用性的内存池（也在RAM区域），其中保存了Java对象。和堆栈不同的是，“内存堆”或“堆”（Heap ）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new 命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价。在堆里分配存储空间时会花掉更长的时间！
(4) 静态存储(static storage)。这儿的“静态”（Static）是指“位于固定位置”（尽管也在RAM 里）。程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但Java 对象本身永远都不会置入静态存储空间。
(5) 常数存储(constant storage)。常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。
(6) 非RAM 存储(non-storage-RAM)。若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。其中两个最主要的例子便是“ 流式对象”和“固定对象” 。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，甚至能将它们恢复成普通的、基于RAM的对象。Java 1.1提供了对轻量级持久化（Lightweight persistence）的支持。未来的版本甚至可能提供更完整的方案。
